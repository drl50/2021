WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:05.809
我注意到 C++ 方法或函数的一个有趣的地方

00:00:05.809 --> 00:00:08.369
实际上我是偶然发现的

00:00:08.369 --> 00:00:12.649
是这样子的 我写了两个函数 都叫做 close_enough 

00:00:12.650 --> 00:00:16.240
让我看看还能不能找到

00:00:16.239 --> 00:00:18.289
其中一个函数目的在于比较两个单精度浮点数

00:00:18.289 --> 00:00:22.660
即 这两个函数的浮点接近 不过并非完全相同

00:00:22.660 --> 00:00:23.740
而在这两个函数浮点足够接近的情况下

00:00:23.739 --> 00:00:25.417
函数返回 true 

00:00:25.417 --> 00:00:26.844
另外一个函数目的在于比较两个网格

00:00:26.844 --> 00:00:29.949
如果这两个函数足够接近于完全相同 那么函数也返回 true

00:00:29.949 --> 00:00:33.615
即 网格里的所有实际值都足够接近

00:00:33.615 --> 00:00:35.130
我让其他人也这样做过

00:00:35.130 --> 00:00:36.690
我不敢相信这居然有效

00:00:36.689 --> 00:00:42.534
我这里有两个同名函数 一个应用于比较网格

00:00:42.534 --> 00:00:45.149
而另一个比较两个单精度浮点 两个函数均能奏效

00:00:45.149 --> 00:00:46.234
这是为什么呢

00:00:46.234 --> 00:00:47.640
为什么可以会有两个同名的函数呢？

00:00:47.640 --> 00:00:50.289
编译器并不把它们看做完全相同的两个函数

00:00:50.289 --> 00:00:52.174
因为两者的签名完全不同

00:00:52.174 --> 00:00:53.439
我的意思是说 如果你签了字

00:00:53.439 --> 00:00:55.304
我也签了字 我们的签名肯定是不一样的

00:00:55.304 --> 00:01:01.000
编译器会读取这些函数和他们的类型

00:01:01.000 --> 00:01:05.635
它读取了这个close_enough向量网格

00:01:05.635 --> 00:01:09.500
使它成为函数名称的一部分

00:01:09.500 --> 00:01:11.420
在这里你看不到

00:01:11.420 --> 00:01:14.320
但是如果你看编译器内部

00:01:14.319 --> 00:01:18.744
你可以看到它从哪里开始处理所有被命名的函数

00:01:18.745 --> 00:01:22.030
以及它们的参数

00:01:22.030 --> 00:01:24.099
以及它们的参数

00:01:24.099 --> 00:01:25.649
所以这就是所谓的超载（overloading）

00:01:25.650 --> 00:01:29.200
比如你想比较网格或者浮点数

00:01:29.200 --> 00:01:33.055
但又不想写两个完全不同的函数 那么就可以这么做

00:01:33.055 --> 00:01:37.805
你不需要将每个函数都命名地不一样

00:01:37.805 --> 00:01:40.098
那样很麻烦

00:01:40.097 --> 00:01:42.875
我们只是想知道对比的结果而已

00:01:42.875 --> 00:01:44.314
可以使用同名的函数 这是 C++ 的特征

00:01:44.314 --> 00:01:46.120
真是个省时省力的好特征

