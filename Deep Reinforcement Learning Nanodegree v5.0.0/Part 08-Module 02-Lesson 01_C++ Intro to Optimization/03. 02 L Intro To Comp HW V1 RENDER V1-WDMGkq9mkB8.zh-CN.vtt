WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.349
优化的目的 是消除不需要的指令

00:00:04.349 --> 00:00:07.084
同时保证程序可以输出你想要的结果

00:00:07.084 --> 00:00:10.893
程序访问内存和执行计算的次数越少

00:00:10.893 --> 00:00:12.705
程序效率越高

00:00:12.705 --> 00:00:15.220
优化不是简单地将你的代码乱塞在某个黑盒子里

00:00:15.220 --> 00:00:18.070
等待它的效率提升

00:00:18.070 --> 00:00:21.085
你还需要了解计算机工作原理 并执行代码

00:00:21.085 --> 00:00:23.495
并重复利用这些知识

00:00:23.495 --> 00:00:25.975
除了硬盘之类的存储介质之外

00:00:25.975 --> 00:00:30.230
电脑基本上有两个硬件与运行程序相关

00:00:30.230 --> 00:00:32.049
CPU 和 RAM

00:00:32.049 --> 00:00:35.282
CPU 或中央处理单元

00:00:35.283 --> 00:00:37.329
有一个部分叫做控制单元

00:00:37.329 --> 00:00:39.960
它执行你代码中包含的指令

00:00:39.960 --> 00:00:43.349
另一部分称为算术逻辑单元

00:00:43.348 --> 00:00:46.029
它负责计算数学和逻辑表达式

00:00:46.030 --> 00:00:49.060
RAM 或随机存取存储器

00:00:49.060 --> 00:00:52.000
用于程序存储变量和指令

00:00:52.000 --> 00:00:55.530
从而支持程序的执行

00:00:55.530 --> 00:00:58.090
这是一个存储介质 就像你的硬盘

00:00:58.090 --> 00:01:02.140
但是它的读写速度要快得多 而且是易失的

00:01:02.140 --> 00:01:04.704
这意味着当你关闭计算机时

00:01:04.704 --> 00:01:06.670
一切数据都会消失

00:01:06.670 --> 00:01:10.724
想象一下 你的硬盘驱动器在你每次关机的时候也是这样吗？

00:01:10.724 --> 00:01:14.109
简而言之 CPU 中的控制单元将读取

00:01:14.109 --> 00:01:18.234
代码中的下一条指令 并通过将数据写入 RAM

00:01:18.234 --> 00:01:19.870
来执行该指令

00:01:19.870 --> 00:01:23.925
或者让算术或逻辑单元进行计算

00:01:23.924 --> 00:01:27.679
与 Python 不同 当你用 C++ 编写程序时

00:01:27.680 --> 00:01:31.120
在你执行指令之前 需要进行编译

00:01:31.120 --> 00:01:34.160
编译器将你的代码重写成一组

00:01:34.159 --> 00:01:38.079
CPU 可以理解的指令 称为机器码

00:01:38.079 --> 00:01:41.370
这就是 CPU 的语言

00:01:41.370 --> 00:01:43.810
所以 编译器实际上发挥了翻译作用

00:01:43.810 --> 00:01:47.112
将你如何理解和编写代码

00:01:47.112 --> 00:01:50.114
与 CPU 如何理解和读取代码连接起来

00:01:50.114 --> 00:01:54.974
例如 你可能会写 int x = 5 这行代码

00:01:54.974 --> 00:01:58.924
而编译器会把这行代码变成这样

00:01:58.924 --> 00:02:02.539
而CPU就会明白 这表示

00:02:02.540 --> 00:02:05.750
将 5 的值存储于 RAM 的特定位置

00:02:05.750 --> 00:02:09.800
该位置可以通过绑定到变量 X 的地址访问

00:02:09.800 --> 00:02:14.180
另一条指令发送一条指令到 CPU

00:02:14.180 --> 00:02:20.314
然后 CPU 将询问存储在与 X 相关的地址处的值 即可检索 X 的值

00:02:20.314 --> 00:02:24.949
而另一条指令可以将地址中存储的值视作 X

00:02:24.949 --> 00:02:29.655
增加 10 然后更新内存中的新值

00:02:29.655 --> 00:02:31.985
所有这些指令都需要时间来执行

00:02:31.985 --> 00:02:35.510
还有一些像三角函数和 IF 语句分支的操作

00:02:35.509 --> 00:02:39.319
这些都是特别低效的

00:02:39.319 --> 00:02:42.049
我们来看一系列的 IF 语句

00:02:42.050 --> 00:02:46.600
这里 我们根据 x 的值来赋值变量 y

00:02:46.599 --> 00:02:52.500
这段代码效率很低 因为它会导致 CPU 两次对比 x 的值

00:02:52.500 --> 00:02:54.960
但是 如果第一个条件为 false

00:02:54.960 --> 00:02:57.974
第二个条件就会自动成立的

00:02:57.974 --> 00:03:00.569
因此 优化时 我们需要重写

00:03:00.569 --> 00:03:05.159
IF语句 具体如下所示

00:03:05.159 --> 00:03:08.585
这个版本的代码则只需要做一次比较

00:03:08.585 --> 00:03:12.570
你可能会认为 这么小的变化在速度上并没有太大的差别

00:03:12.569 --> 00:03:15.784
如果只运行一次 可能差别真的不大

00:03:15.784 --> 00:03:18.650
但想象一下 如果这些语句是在 for 循环内

00:03:18.650 --> 00:03:21.754
运行数千或数百万次

00:03:21.754 --> 00:03:25.414
那么这种低效的代码肯定会造成整个程序的效率低下

00:03:25.414 --> 00:03:28.759
了解计算机如何运作可以帮助你

00:03:28.759 --> 00:03:32.750
确定哪些计算可能会拖慢你的程序

00:03:32.750 --> 00:03:35.944
对计算机内部发生的事情了解更深刻

00:03:35.944 --> 00:03:40.069
你就能更成功地提高程序的效率

