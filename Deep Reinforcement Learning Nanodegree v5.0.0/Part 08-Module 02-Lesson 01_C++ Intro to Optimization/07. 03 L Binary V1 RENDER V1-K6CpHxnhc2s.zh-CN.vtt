WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.149
从高层次来看

00:00:02.149 --> 00:00:06.980
你已经看到了限制 CPU 指令可以使你的代码运行得更快

00:00:06.980 --> 00:00:09.890
作为人类 我们考虑采用 C++ 等编程语言

00:00:09.890 --> 00:00:13.839
与电脑进行互动

00:00:13.839 --> 00:00:17.489
然而 计算机只能理解二进制指令

00:00:17.489 --> 00:00:23.125
所以你写的所有东西都会被计算机看成是一连串的 0 和 1

00:00:23.125 --> 00:00:25.079
让我们深入了解一下电脑

00:00:25.079 --> 00:00:28.169
如何使用二进制在内存中存储信息

00:00:28.170 --> 00:00:32.219
了解你的 C++ 程序如何存储信息可以帮助你

00:00:32.219 --> 00:00:37.420
避免不必要的内存访问 从而避免浪费宝贵的 CPU 周期

00:00:37.420 --> 00:00:40.170
让我们思考一下如何用二进制表示一个变量

00:00:40.170 --> 00:00:42.719
二进制采用二次幂来描述

00:00:42.719 --> 00:00:46.125
一个通常将最低有效位数放在右边的值

00:00:46.125 --> 00:00:48.979
对于二进制表示中的每个位置

00:00:48.979 --> 00:00:52.739
你取一个 1 或 0 的二进制值并乘以

00:00:52.740 --> 00:00:57.635
与该位置相关的二次幂并使用基于零的编号

00:00:57.634 --> 00:01:01.369
最后 将结果加在一起得到十进制值

00:01:01.369 --> 00:01:03.989
现在我们来看几个例子

00:01:03.990 --> 00:01:07.530
看看数字 1 到 5 的二进制表示

00:01:07.530 --> 00:01:10.835
十进制数 0 的二进制表示仍然是 0

00:01:10.834 --> 00:01:17.599
为了解决这个问题 你采用 0 乘以 2 的零次幂 算出来等于 0

00:01:17.599 --> 00:01:20.699
十进制数 1 的二进制表示是 1

00:01:20.700 --> 00:01:25.680
因为 1 乘以 2 的零次幂 等于 1

00:01:25.680 --> 00:01:29.700
二进制数 10 等于十进制数 2

00:01:29.700 --> 00:01:32.939
你也需要乘以 2 的一次幂

00:01:32.939 --> 00:01:36.075
因为 1 乘以 2 的一次幂

00:01:36.075 --> 00:01:40.075
加上 0 乘以 2 的零次幂 等于 2

00:01:40.075 --> 00:01:41.909
采用相同的规则 二进制数 11

00:01:41.909 --> 00:01:45.265
等于 十进制数 3

00:01:45.265 --> 00:01:47.070
因为 1 乘以

00:01:47.069 --> 00:01:52.619
2的一次幂 加上 1 乘以 2 的零次幂 等于 3

00:01:52.620 --> 00:01:56.460
二进制数 100 等于十进制数 4

00:01:56.459 --> 00:02:00.029
1 乘以 2 的二次幂 加上 0 乘以

00:02:00.030 --> 00:02:05.820
2 的一次幂 加上  0 乘以  2 的零次幂  等于 4

00:02:05.819 --> 00:02:10.139
最后 二进制数 101 等于十进制数 5

00:02:10.139 --> 00:02:11.714
以此类推

00:02:11.715 --> 00:02:16.259
1 乘以 乘以 2 的二次幂 加上 0 乘以

00:02:16.259 --> 00:02:22.804
2 的一次幂 加上 1 乘以  2 的零次幂  等于 5

00:02:22.805 --> 00:02:25.775
你可以采用二进制数表示任何十进制数

00:02:25.775 --> 00:02:28.680
例如 十进制数 25 在二进制数中 将表示为

00:02:28.680 --> 00:02:31.355
11001

00:02:31.354 --> 00:02:34.844
在这里 你能看到如何计算出这个结果

00:02:34.844 --> 00:02:38.995
计算机以二进制表示所有变量 而不仅仅只能表示整数

00:02:38.995 --> 00:02:43.289
这意味着即使是字符和浮点数都可以采用二进制表示

00:02:43.289 --> 00:02:47.759
但是 你的计算机不能一次存储任意数量的 0 和 1

00:02:47.759 --> 00:02:50.519
相反 内存是存储在八个二进制数字中

00:02:50.520 --> 00:02:55.020
其中 每个数字被称为一个位

00:02:55.020 --> 00:02:59.040
你可以根据这些 8 位二进制来考虑计算机的内存

00:02:59.039 --> 00:03:02.294
而每个 8 位二进制称为一个字节

00:03:02.294 --> 00:03:08.369
在 C++ 中 最小的变量为 8 位二进制 或者说 一个字节

00:03:08.370 --> 00:03:13.500
一个 16 位整数有两个字节 一个 32 位整数采用四个字节

00:03:13.500 --> 00:03:15.824
一个浮点数 也采用 四个字节 进行存放

00:03:15.824 --> 00:03:18.629
在 C++ 中 变量通常采用

00:03:18.629 --> 00:03:21.935
变量类型指定的内存量

00:03:21.935 --> 00:03:28.094
例如 数字 3,378 只需要 12 个字节存储

00:03:28.094 --> 00:03:30.932
不过却表示为一个 16 字节整数

00:03:30.932 --> 00:03:34.379
那么需要采用零在左侧填充两个字节

00:03:34.379 --> 00:03:36.629
作为一个 32 字节整数

00:03:36.629 --> 00:03:38.909
它需要更多零进行填充

00:03:38.909 --> 00:03:41.954
基本上意味着最重要的位将是零

00:03:41.955 --> 00:03:44.895
在 C++ 中 你可以宣告一个 16 字节

00:03:44.895 --> 00:03:48.240
32 字节 或者甚至是一个 64 字节

00:03:48.240 --> 00:03:50.617
所有这些都意味着这个整数正采用两个

00:03:50.617 --> 00:03:53.169
四个 或者八个字节内存

00:03:53.169 --> 00:03:58.079
你可以开始理解这些可用的字节数如何变成了一种约束

00:03:58.080 --> 00:04:00.565
如果一个整数只能使用 32 字节

00:04:00.564 --> 00:04:04.550
那么其最大值将是所有等于 1 的字节数

00:04:04.550 --> 00:04:06.010
十进制等值是

00:04:06.009 --> 00:04:14.799
4,294,967,295 这个数字

00:04:14.800 --> 00:04:18.115
是 32 字节整数能够存储的最大值

00:04:18.115 --> 00:04:21.415
并且如果你正在使用带符号数 这个值甚至更小

00:04:21.415 --> 00:04:25.330
现在你已经理解了如何用二进制表示变量

00:04:25.329 --> 00:04:29.734
你将学习 C++ 如何存储和提取这些信息

00:04:29.735 --> 00:04:32.290
请记住 优化你的代码的一部分会

00:04:32.290 --> 00:04:36.230
牵涉到限制你的程序读写内存的次数

00:04:36.230 --> 00:04:40.870
你需要了解何时以及为什么会发生这些读取和写入操作

